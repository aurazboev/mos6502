<!DOCTYPE html>
<!-- saved from url=(0060)https://khale.github.io/iit-cs562-s24-site/projects/02-6502/ -->
<html lang="en-US" data-theme="light"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=Edge"><link rel="shortcut icon" href="https://khale.github.io/iit-cs562-s24-site/favicon.ico" type="image/x-icon"><link rel="stylesheet" href="./Project 1 _ CS 562_files/just-the-docs-default.css"> <script type="text/javascript" src="./Project 1 _ CS 562_files/lunr.min.js"></script> <script type="text/javascript" src="./Project 1 _ CS 562_files/just-the-docs.js"></script><meta name="viewport" content="width=device-width, initial-scale=1"><title>Project 1 | CS 562</title><meta name="generator" content="Jekyll v3.9.5"><meta property="og:title" content="Project 1"><meta name="author" content="Kyle Hale"><meta property="og:locale" content="en_US"><meta name="description" content="Into the Depths of Virtualization and Virtual Machines"><meta property="og:description" content="Into the Depths of Virtualization and Virtual Machines"><link rel="canonical" href="https://khale.github.io/iit-cs562-s24-site/projects/02-6502/"><meta property="og:url" content="https://khale.github.io/iit-cs562-s24-site/projects/02-6502/"><meta property="og:site_name" content="CS 562"><meta property="og:type" content="website"><meta name="twitter:card" content="summary"><meta property="twitter:title" content="Project 1"> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"WebPage","author":{"@type":"Person","name":"Kyle Hale"},"description":"Into the Depths of Virtualization and Virtual Machines","headline":"Project 1","url":"https://khale.github.io/iit-cs562-s24-site/projects/02-6502/"}</script><style type="text/css">iframe#teal-job-tracker-iframe-stable {
    min-width: 380px !important;
    width: 380px !important;
    min-height: 100vh !important;
    height: 100vh !important;
  }

  @media print {
    #teal-job-tracker-root-stable, #teal-job-tracker-companion-root-stable {
      display: none !important;
    }
  }</style></head><body data-new-gr-c-s-check-loaded="14.1190.0" data-gr-ext-installed=""> <svg xmlns="http://www.w3.org/2000/svg" style="display: none;"> <symbol id="svg-link" viewBox="0 0 24 24"><title>Link</title><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-link"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path> </svg> </symbol> <symbol id="svg-search" viewBox="0 0 24 24"><title>Search</title><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-search"> <circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line> </svg> </symbol> <symbol id="svg-menu" viewBox="0 0 24 24"><title>Menu</title><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line> </svg> </symbol> <symbol id="svg-arrow-right" viewBox="0 0 24 24"><title>Expand</title><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-right"><polyline points="9 18 15 12 9 6"></polyline> </svg> </symbol> <symbol id="svg-doc" viewBox="0 0 24 24"><title>Document</title><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file"><path d="M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z"></path><polyline points="13 2 13 9 20 9"></polyline> </svg> </symbol> </svg> <script type="text/javascript" src="./Project 1 _ CS 562_files/toggle_init.js"></script><div class="side-bar"><div class="site-header"> <a href="https://khale.github.io/iit-cs562-s24-site/" class="site-title lh-tight"> CS 562 </a> <a href="https://khale.github.io/iit-cs562-s24-site/projects/02-6502/#" id="menu-button" class="site-button"> <svg viewBox="0 0 24 24" class="icon"><use xlink:href="#svg-menu"></use></svg> </a></div><nav role="navigation" aria-label="Main" id="site-nav" class="site-nav"><ul class="nav-list"><li class="nav-list-item"><a href="https://khale.github.io/iit-cs562-s24-site/calendar/" class="nav-list-link">Course Calendar</a></li><li class="nav-list-item"><a href="https://khale.github.io/iit-cs562-s24-site/assets/notes/emu/" class="nav-list-link">Emulation</a></li><li class="nav-list-item active"><a href="https://khale.github.io/iit-cs562-s24-site/projects/02-6502/#" class="nav-list-expander"><svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg></a><a href="https://khale.github.io/iit-cs562-s24-site/projects/" class="nav-list-link active">Projects</a><ul class="nav-list"><li class="nav-list-item"><a href="https://khale.github.io/iit-cs562-s24-site/projects/01-6502-prelim/" class="nav-list-link">Project 1 Prelim</a></li><li class="nav-list-item active"><a href="https://khale.github.io/iit-cs562-s24-site/projects/02-6502/" class="nav-list-link active">Project 1</a></li><li class="nav-list-item"><a href="https://khale.github.io/iit-cs562-s24-site/projects/03-hawkbeans/" class="nav-list-link">Project 2</a></li><li class="nav-list-item"><a href="https://khale.github.io/iit-cs562-s24-site/projects/04-micro-vmm/" class="nav-list-link">Project 3</a></li><li class="nav-list-item"><a href="https://khale.github.io/iit-cs562-s24-site/projects/05-hawker/" class="nav-list-link">Project 4</a></li><li class="nav-list-item"><a href="https://khale.github.io/iit-cs562-s24-site/projects/06-research/" class="nav-list-link">Project X</a></li></ul></li><li class="nav-list-item"><a href="https://khale.github.io/iit-cs562-s24-site/schedule/" class="nav-list-link">Schedule</a></li><li class="nav-list-item"><a href="https://khale.github.io/iit-cs562-s24-site/staff/" class="nav-list-link">Staff</a></li><li class="nav-list-item"><a href="https://khale.github.io/iit-cs562-s24-site/about/" class="nav-list-link">Syllabus</a></li></ul></nav><footer class="site-footer"> This site uses <a href="https://github.com/pmarsceill/just-the-docs">Just the Docs</a>, a documentation theme for Jekyll.</footer></div><div class="main" id="top"><div id="main-header" class="main-header"><div class="search"><div class="search-input-wrap"> <input type="text" id="search-input" class="search-input" tabindex="0" placeholder="Search CS 562" aria-label="Search CS 562" autocomplete="off"> <label for="search-input" class="search-label"><svg viewBox="0 0 24 24" class="search-icon"><use xlink:href="#svg-search"></use></svg></label></div><div id="search-results" class="search-results"></div></div><nav aria-label="Auxiliary" class="aux-nav"><ul class="aux-nav-list"><li class="aux-nav-list-item"> <a href="https://halek.co/" class="site-button"> Kyle C. Hale </a></li></ul></nav></div><div id="main-content-wrap" class="main-content-wrap"><nav aria-label="Breadcrumb" class="breadcrumb-nav"><ol class="breadcrumb-nav-list"><li class="breadcrumb-nav-list-item"> <a href="https://khale.github.io/iit-cs562-s24-site/projects/">Projects</a></li><li class="breadcrumb-nav-list-item"> <span>Project 1</span></li></ol></nav><div id="main-content" class="main-content" role="main"><h1 id="project-1-hawknest-6502v-emulator">Project 1: Hawknest 6502v Emulator</h1><p>Released: Thursday, 01/18/2024 <strong>Due Date: Friday, 02/09/2024 11:59PM CST</strong></p><h2 id="overview">Overview</h2><p>For this project, you will be completing the implementation of the Hawknest emulator. This emulator will be built around the 6502v processor, a version of the MOS 6502 CPU which I’ve modified slightly for our convenience. The v indicates that this CPU supports paravirtual extensions (namely, a new instruction).</p><p>The goals of this project are to:</p><ul><li>Give you experience working with a fairly large C source tree</li><li>Help you understand how system emulation works</li><li>Refresh your understanding of ISAs and the internal operation of CPUs</li><li>Have fun!</li></ul><p>Keep in mind that this project carries many of the imperfections of real-world code. If we encounter bugs or hiccups, we will work through them together.</p><h2 id="part-1-getting-started">Part 1: Getting Started</h2><p>The ideal way to start with this project is using a Vagrant VM. Much like Docker for containers, this allows you to quickly provision virtual machines based on pre-defined configuration files. I’ve set up one of these Vagrantfiles for you so that you don’t have to deal with the headache of different system packages etc. First install <a href="https://vagrantup.com/">Vagrant</a> on your machine as well as a provider, such as <a href="https://virtualbox.org/">VirtualBox</a> or <a href="https://www.vmware.com/products/workstation-pro.html">VMWare</a> (paid).</p><p>Once you get Vagrant up and running, you will need to download the Hawknest skeleton code. We will be working primarily with <code class="language-plaintext highlighter-rouge">git</code>, so make sure you are familiar with the basics. To get the code, run the following in your machine:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git clone https://github.com/HExSA-Lab/hawknest-skeleton.git
cd hawknest-skeleton
</code></pre></div></div><p>This will fetch the handout code from our public git repo. Notice that in that directory there is a Vagrantfile. To use it, just run:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vagrant up
</code></pre></div></div><p>If you’re using the VirtualBox backend (which is probably the easiest), you will probably also have to install the VirtualBox Guest plugins for Vagrant before running <code class="language-plaintext highlighter-rouge">vagrant up</code>. You can do so like this:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vagrant plugin install vagrant-vbguest
</code></pre></div></div><h2 id="part-2-building-and-running-hawknest">Part 2: Building and Running Hawknest</h2><p>This section will get you to the point where you can build and run the Hawknest emulator.</p><h3 id="prerequisites">Prerequisites</h3><p>You should not have to install any prerequisite packages if you are using Vagrant. One thing to note however, is that the NES emulator mode of Hawknest will only work if you boot up the Vagrant VM with a GUI (this should happen by default, but we’ve seen issues with this before. Come see us if this is the case).</p><h3 id="building-the-emulator">Building the Emulator</h3><p>Once you have installed the prerequisites, you should be able to build the emulator as follows:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>make
build/emu/gcc/debug/mos6502/vmcall.o &lt;- emu/mos6502/vmcall.c
build/emu/gcc/debug/mos6502/mos6502-common.o &lt;- emu/mos6502/mos6502-common.c
build/emu/gcc/debug/mos6502/mos6502.o &lt;- emu/mos6502/mos6502-skeleton.c
build/emu/gcc/debug/nes/io_reg.o &lt;- emu/nes/io_reg.c
build/emu/gcc/debug/nes/nrom.o &lt;- emu/nes/nrom.c
build/emu/gcc/debug/nes/sxrom.o &lt;- emu/nes/sxrom.c
build/emu/gcc/debug/nes/mmc1.o &lt;- emu/nes/mmc1.c
build/emu/gcc/debug/nes/ppu.o &lt;- emu/nes/ppu.c
build/emu/gcc/debug/main.o &lt;- emu/main.c
build/emu/gcc/debug/shell.o &lt;- emu/shell.c
build/emu/gcc/debug/ines.o &lt;- emu/ines.c
build/emu/gcc/debug/rc.o &lt;- emu/rc.c
build/emu/gcc/debug/timekeeper.o &lt;- emu/timekeeper.c
build/emu/gcc/debug/memory.o &lt;- emu/memory.c
build/emu/gcc/debug/membus.o &lt;- emu/membus.c
build/emu/gcc/debug/reset_manager.o &lt;- emu/reset_manager.c
build/emu/gcc/debug/fileio.o &lt;- emu/fileio.c
Linking bin/hawknest-gcc-debug...
</code></pre></div></div><p>You should now have a binary called <code class="language-plaintext highlighter-rouge">hawknest-gcc-debug</code> in a newly-created <code class="language-plaintext highlighter-rouge">bin/</code> directory. If you run it without any arguments (or with the <code class="language-plaintext highlighter-rouge">-h</code> flag), you will get a help message like so:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bin/hawknest-gcc-debug
Usage: bin/hawknest-gcc-debug [options] &lt;rom-path&gt;
Options:
  --palette or -p &lt;path&gt; : Use the NES palette at &lt;path&gt;
  --cscheme or -c &lt;path&gt; : Use the NES controller scheme at &lt;path&gt;
  --scale   or -s &lt;int&gt;  : Scale NES output by &lt;int&gt;
  --help    or -h        : Print this message
  --version or -V        : Print version information
</code></pre></div></div><p>Probably the only option here you’ll ever have to worry about is the <code class="language-plaintext highlighter-rouge">--scale</code> argument, which scales the size of the GUI window for the NES emulator by an integer factor.</p><h3 id="building-roms-test-code">Building ROMs (test code)</h3><p>I’ve supplied you with some simple test programs in the <code class="language-plaintext highlighter-rouge">test/</code> directory in the main source tree: <code class="language-plaintext highlighter-rouge">hello.c</code> and <code class="language-plaintext highlighter-rouge">primes.c</code>. <code class="language-plaintext highlighter-rouge">hello.c</code> tests writing a “Hello World” message to stdout using the paravirtual interface, while <code class="language-plaintext highlighter-rouge">primes.c</code> goes a step further to implement an interactive prime-number-checker. These will not work out of the box, and you probably don’t want to focus your effort there. Rather, you’ll want to look at the unit tests (<code class="language-plaintext highlighter-rouge">test/*.s</code>) which test small instruction sequences for the 6502 and do not rely on libc to have initialized. The nice part about these tests is that the first instruction you see in the <code class="language-plaintext highlighter-rouge">.s</code> file is actually the first instruction to run on the machine (this is not true for the <code class="language-plaintext highlighter-rouge">.c</code> files). You can compile all of these tests to Hawknest ROMs by making the tests target in the project root:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>make tests
build/test/hello.s &lt;- test/hello.c
build/test/hello.o &lt;- build/test/hello.s
build/lib/intr.s &lt;- lib/intr.c
build/lib/intr.o &lt;- build/lib/intr.s
build/lib/crt0.o &lt;- lib/crt0.s
build/lib/ctype.o &lt;- lib/ctype.s
build/lib/exehdr.o &lt;- lib/exehdr.s
build/lib/mainargs.o &lt;- lib/mainargs.s
build/lib/paravirt.o &lt;- lib/paravirt.s
Linking bin/hawknest.lib...
Linking bin/hello
build/test/primes.s &lt;- test/primes.c
build/test/primes.o &lt;- build/test/primes.s
Linking bin/primes
build/test/00_lda0.o &lt;- test/00_lda0.s
Linking bin/00_lda0
build/test/01_lda1.o &lt;- test/01_lda1.s
Linking bin/01_lda1
build/test/02_lda2.o &lt;- test/02_lda2.s
Linking bin/02_lda2
build/test/03_sta0.o &lt;- test/03_sta0.s
Linking bin/03_sta0
...
</code></pre></div></div><p>You’ll also find a <code class="language-plaintext highlighter-rouge">modules.mk</code> file in the <code class="language-plaintext highlighter-rouge">test/</code> directory, which informs the <code class="language-plaintext highlighter-rouge">Makefile</code> of the test files to compile. If you want to write your own test, just put the source file in <code class="language-plaintext highlighter-rouge">test/</code> and add it to the <code class="language-plaintext highlighter-rouge">modules.mk</code> file; both C (<code class="language-plaintext highlighter-rouge">.c</code>) and 6502 assembly (<code class="language-plaintext highlighter-rouge">.s</code>) files will work, but <code class="language-plaintext highlighter-rouge">.s</code> files will not be linked with the <code class="language-plaintext highlighter-rouge">cc65</code> C runtime system. Behind the scenes, the Makefile invokes <code class="language-plaintext highlighter-rouge">cc65</code>, <code class="language-plaintext highlighter-rouge">ca65</code>, and <code class="language-plaintext highlighter-rouge">ld65</code>, just as in your preliminary project, but using a custom library (<code class="language-plaintext highlighter-rouge">bin/hawknest.lib</code>, built from the sources in <code class="language-plaintext highlighter-rouge">lib/</code>) and a custom linker script (<code class="language-plaintext highlighter-rouge">cfg/hawknest.cfg</code>).</p><h3 id="running-hawknest">Running Hawknest</h3><p>Once you have your compiled ROM files, you can run them in Hawknest. For example, we could run the ROM file for the <code class="language-plaintext highlighter-rouge">hello.c</code> test like this:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bin/hawknest-gcc-debug bin/hello
</code></pre></div></div><p>Notice that nothing happens: this is because there’s no CPU to run the program! You will implement this, and when you do, you’ll start to see some output here. You can also start Hawknest in an interactive shell, which is useful for debugging purposes:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bin/hawknest-gcc-debug -i bin/hello
$(hawknest-shell)&gt;
</code></pre></div></div><p>Here you can type commands into the interactive shell, but aside from the memory <code class="language-plaintext highlighter-rouge">peek</code>, <code class="language-plaintext highlighter-rouge">poke</code>, and <code class="language-plaintext highlighter-rouge">dump</code> commands, they won’t do anything. The memory commands will work just fine since I’ve already implemented the memory controller, RAM, and ROM subsystems for you. Note that you can also enter the shell for a running ROM, even if you didn’t pass the <code class="language-plaintext highlighter-rouge">-i</code> argument to the Hawknest executable: just send a SIGINT (mapped to <code class="language-plaintext highlighter-rouge">Ctrl-C</code> in most terminal emulators) to Hawknest to pause the CPU and open the shell. This also applies for stopping continue or step commands early.</p><p>While working on your project, you may want to have debugging prints that only appear when you are debugging your CPU. I’ve provided a macro for you to achieve this. The macro is called <code class="language-plaintext highlighter-rouge">DEBUG_PRINT</code>. It works similarly to <code class="language-plaintext highlighter-rouge">printf</code>, but automatically appends a <code class="language-plaintext highlighter-rouge">\n</code> to each printout, and includes the filename and line number of the printout itself. Additionally, it will only produce output when the code is compiled for debugging (which is the default). See the <a href="https://khale.github.io/iit-cs562-s24-site/projects/02-6502/#appendix-1-configuring-the-build-process">appendix</a> section for additional Hawknest compilation options.</p><h3 id="testing-hawknest">Testing Hawknest</h3><p>I’ve tried to make things a bit easier on you by providing unit tests for a fairly large subset (but not all) of the ISA. These tests are by no means exhaustive, but they can at least help to guide your development. To run a test, simply use the binary in the <code class="language-plaintext highlighter-rouge">bin/</code> directory, for example:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>make tests
bin/hawknest-gcc-debug bin/00_lda0
</code></pre></div></div><p>will test the <code class="language-plaintext highlighter-rouge">lda</code> instruction using your emulator implementation. Essentially what all of these unit tests do is execute a few instructions and dump the state of the machine afterwards (using a special instruction). Note that you’ll want to have the initial guts of your emulator in place before this will even work (instruction fetch, decode, execute etc.) because the state dumping relies on the ability of instructions to execute.</p><p>I’ve also provided a testing framework for you which will run all of the tests automatically. To use it, run:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>make run-unit-tests
</code></pre></div></div><p>If you haven’t implemented anything yet and you run this, it will hang for a bit and you’ll see it time out, producing a failed test. When you get more working, you’ll see more useful output: your machine’s state dump is compared to the state dump of our reference code. If it doesn’t match, the test fails, and the framework will print a diff showing where the machine states differ.</p><h3 id="working-with-instrumentation">Working with Instrumentation</h3><p>By default, Hawknest is compiled with embedded runtime instrumentation, namely <code class="language-plaintext highlighter-rouge">UndefinedBehaviorSanitizer</code> and <code class="language-plaintext highlighter-rouge">AddressSanitizer</code>. The former detects and reports many instances of undefined behavior, and is always non-fatal. This is to say, <code class="language-plaintext highlighter-rouge">UndefinedBehaviorSanitizer</code> will never halt a program because it detects an instance of undefined behavior.</p><p><code class="language-plaintext highlighter-rouge">AddressSanitizer</code>, on the other hand, is always fatal when it detects errors (mostly invalid memory access). Its checks are useful, but if it becomes a nuisance, you can disable it at build-time like this:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>make NO_ASAN=1
</code></pre></div></div><p>On Linux, <code class="language-plaintext highlighter-rouge">AddressSanitizer</code> also performs a memory-leak check at program termination. This can be a bit noisy and annoying, as it includes leaks from within external libraries (e.g., SDL), and often fails to track down the origin of a given leak. Unfortunately, there’s no way to disable this at build-time without disabling all of <code class="language-plaintext highlighter-rouge">AddressSanitizer</code>, but it can be disabled at execution time by setting the <code class="language-plaintext highlighter-rouge">ASAN_OPTIONS</code> environment variable appropriately; in bash-compatible shells that looks like this:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ASAN_OPTIONS=detect_leaks=0 bin/hawknest-gcc-debug &lt;rom_path&gt;
</code></pre></div></div><p>This instrumentation is enabled for the <em>entire</em> Hawknest platform, not just the part you’re working on, so if you see an error report in code you didn’t write, let me know!</p><h2 id="part-3-implementation">Part 3: Implementation</h2><p>This section will outline some strategies for designing your 6502v with readable code.</p><h3 id="strategy">Strategy</h3><p>The skeleton has been set up such that only <code class="language-plaintext highlighter-rouge">emu/mos6502/mos6502-skeleton.c</code> should need to be modified to build the CPU. There’s much more detailed information in that file, but the gist is that you’ll need to fill in <code class="language-plaintext highlighter-rouge">mos6502_step(...)</code> such that it steps the CPU forward by one instruction. A few helper routines for reading and writing memory are already provided, along with some coarse cycle counting. While you could write the entire CPU implementation inside <code class="language-plaintext highlighter-rouge">mos6502_step</code>, we recommended that you add additional functions liberally.</p><p>If you’re the kind of person that likes to split things into multiple files, the <code class="language-plaintext highlighter-rouge">Makefile</code> is built to accommodate that. If you place an additional source file in <code class="language-plaintext highlighter-rouge">emu/mos6502/</code> and add it to <code class="language-plaintext highlighter-rouge">emu/mos6502/modules.mk</code>, it’ll automatically be compiled and linked into Hawknest when you run <code class="language-plaintext highlighter-rouge">make</code>. Adding a header file to <code class="language-plaintext highlighter-rouge">emu/include/mos6502/</code> requires no extra steps; anything in <code class="language-plaintext highlighter-rouge">emu/include/</code> is immediately available for inclusion by source files. The <code class="language-plaintext highlighter-rouge">Makefile</code> also understands source and header dependencies, so you don’t need to <code class="language-plaintext highlighter-rouge">make clean</code> when you edit a header file; just run <code class="language-plaintext highlighter-rouge">make</code> like usual.</p><h3 id="suggested-tools">Suggested Tools</h3><p>When navigating and working with a large codebase, there are several tools you might want to get familiar with. The first is <code class="language-plaintext highlighter-rouge">ctags</code>. This is a utility which creates an index of all the functions and symbols in your source tree, which you can then use to navigate easily within a text editor like <code class="language-plaintext highlighter-rouge">vi</code>.</p><p>For example, to use <code class="language-plaintext highlighter-rouge">ctags</code> for this project, in the Hawknest directory, run the following (you may have to install the <code class="language-plaintext highlighter-rouge">ctags</code> package):</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ctags -R
</code></pre></div></div><p>This will create a <code class="language-plaintext highlighter-rouge">tags</code> file in this directory. To use this in <code class="language-plaintext highlighter-rouge">vi</code> or <code class="language-plaintext highlighter-rouge">vim</code>, add the following line to your <code class="language-plaintext highlighter-rouge">.vimrc</code> file in your home directory:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tags=tags;/
</code></pre></div></div><p>Now, within <code class="language-plaintext highlighter-rouge">vi</code> or <code class="language-plaintext highlighter-rouge">vim</code>, if you hover over a symbol that you want to see the definition of, e.g. a function, you can navigate to it simply by pressing `ctrl</p><ul><li>]<code class="language-plaintext highlighter-rouge">. You can go back to where you were before by typing </code>ctrl + t`. Emacs has similar capabilities.</li></ul><p>Other tools that might be useful:</p><ul><li><code class="language-plaintext highlighter-rouge">gdb</code> / <code class="language-plaintext highlighter-rouge">lldb</code> : both interactive debuggers for compiled C/C++ programs</li><li><code class="language-plaintext highlighter-rouge">grep</code> / <code class="language-plaintext highlighter-rouge">ack</code> / <code class="language-plaintext highlighter-rouge">the_silver_searcher</code> / <code class="language-plaintext highlighter-rouge">ripgrep</code> : all tools that search for text strings in a source tree (roughly in order from slowest to fastest). You can also use plugins like <a href="https://github.com/kien/ctrlp.vim">Ctrl-p</a> for your editor to do interactive searching/fuzzy finding</li><li><code class="language-plaintext highlighter-rouge">tmux</code> : useful for having multiple terminal windows open at once</li><li><code class="language-plaintext highlighter-rouge">tig</code> : command-line graphical interface for git repos (see also <a href="https://github.com/jesseduffield/lazygit">lazygit</a>)</li></ul><h2 id="updates">Updates</h2><p>As we progress on this project, I may be making updates to the sections of code that you are not working on (e.g. graphics code, interrupt handling, libraries etc.). If I do make updates, I will ask you to get them from the repo using:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git pull
</code></pre></div></div><p>Because of this, I would advise against adding code to parts of the system outside of <code class="language-plaintext highlighter-rouge">emu/mos6502/mos6502.c</code> (and your support files) unless absolutely necessary.</p><h2 id="handin">Handin</h2><p>Once you’re convinced that your 6502 implementation is complete, you will hand in your code using an automated hand-in utility. Simply run:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>make handin
</code></pre></div></div><p>to start the process. The handin script will ask you for your information and will use it to submit to my handin server. Note that you can continue to submit until the deadline.</p><h2 id="equal-contribution">Equal Contribution</h2><p>Since you’re working in groups, I expect that I’ll see equal contribution among group members when I look at your code. Make liberal use of <code class="language-plaintext highlighter-rouge">git</code> commits to make this clear For example, I would commit with:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>...add stuff to git index using git add...
git commit --author="Kyle Hale &lt;khale@cs.iit.edu&gt;"
</code></pre></div></div><p>to take ownership of a commit.</p><p>Make sure to include a descriptive line such as <code class="language-plaintext highlighter-rouge">"Added implementation of JMP instruction."</code></p><h2 id="appendix-1-configuring-the-build-process"><a href="https://khale.github.io/iit-cs562-s24-site/projects/02-6502/build-config"></a>Appendix 1: Configuring the Build Process</h2><p>By default, invoking make compiles Hawknest using GCC in a “debug” configuration, but this is not the only way Hawknest can be built. Hawknest can be compiled using either Clang or GCC (with custom executables for either), and has three available compilation “modes”: <code class="language-plaintext highlighter-rouge">DEBUG</code>, <code class="language-plaintext highlighter-rouge">OPT</code>, and <code class="language-plaintext highlighter-rouge">RELEASE</code>. These are set using the <code class="language-plaintext highlighter-rouge">COMPILER</code> and <code class="language-plaintext highlighter-rouge">MODE</code> variables, so to compile with Clang in <code class="language-plaintext highlighter-rouge">OPT</code> mode:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>make COMPILER=CLANG MODE=OPT
</code></pre></div></div><p>The build artifacts and final binaries are stored separately for each mode, so they will never conflict. That said, only one <code class="language-plaintext highlighter-rouge">COMPILER</code> and <code class="language-plaintext highlighter-rouge">MODE</code> can be used for a given <code class="language-plaintext highlighter-rouge">make</code> invocation. The name of the final binary reflects these compilation options, so the above invocation would produce <code class="language-plaintext highlighter-rouge">bin/hawknest-clang-opt</code>.</p><h3 id="modes">Modes</h3><p>The compilation mode has the most pronounced effect on the behavior and performance of the final executable.</p><ul><li><code class="language-plaintext highlighter-rouge">DEBUG</code> mode is optimized for debugging. It’s the only mode under which the <code class="language-plaintext highlighter-rouge">DEBUG_PRINT</code> macro is enabled, and it compiles Hawknest with a couple pieces of runtime instrumentation (<code class="language-plaintext highlighter-rouge">ubsan</code> and <code class="language-plaintext highlighter-rouge">asan</code>), which serve to catch common cases of undefined behavior or out-of-bounds memory accesses. <code class="language-plaintext highlighter-rouge">DEBUG</code> mode also enables a number of internal sanity checks within the skeleton, so if you manage to trip something outside of <code class="language-plaintext highlighter-rouge">mos6502.c</code>, let me know! Finally, <code class="language-plaintext highlighter-rouge">DEBUG</code> mode avoids compiler optimizations that would interfere with the use of an interactive debugger like <code class="language-plaintext highlighter-rouge">gdb</code> (namely inlining).</li><li><code class="language-plaintext highlighter-rouge">OPT</code> keeps all the runtime instrumentation and sanity checks of <code class="language-plaintext highlighter-rouge">DEBUG</code> mode, but disables <code class="language-plaintext highlighter-rouge">DEBUG_PRINT</code> and enables almost all compiler optimizations. This makes it substantially less useful if you like an interactive debugger, but it also often runs substantially faster.</li><li><code class="language-plaintext highlighter-rouge">RELEASE</code> mode takes the brakes off completely, dropping all runtime instrumentation and enabling link-time optimization. It’s pretty useless for debugging, but it may be required to run NES games at full speed if you have a slower machine.</li></ul><h3 id="compilers">Compilers</h3><p>The difference between compilers is not particularly pronounced outside of the diagnostics they produce, but if you prefer using Clang over GCC, you can specify the <code class="language-plaintext highlighter-rouge">COMPILER</code> variable:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>make COMPILER=CLANG
</code></pre></div></div><p>It also may be the case that your compiler is not available with the usual name; you can override the command invoked for a particular compiler by specifying the corresponding <code class="language-plaintext highlighter-rouge">EXEC</code> variable, e.g.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>make GCC_EXEC=gcc-8
</code></pre></div></div><p>This works for specifying the CC65 toolchain executables as well, so if they’re not in your <code class="language-plaintext highlighter-rouge">PATH</code>, you can specify them manually:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>make CC65_EXEC=path/to/cc65 AR65_EXEC=path/to/ar65 CA65_EXEC=path/to/ca65 LD65_EXEC=path/to/ld65
</code></pre></div></div><p>If all the CC65 executables are in the same directory, the above can be shortened to:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>make CC65_PREFIX=path/to/cc65/prefix/dir
</code></pre></div></div><h2 id="appendix-2-other-potentially-useful-macros">Appendix 2: Other Potentially-Useful Macros</h2><p>Internally, Hawknest uses <code class="language-plaintext highlighter-rouge">ASSERT</code> and <code class="language-plaintext highlighter-rouge">UNREACHABLE</code> macros for sanity checks, and these are exposed to you as well through <code class="language-plaintext highlighter-rouge">base.h</code>. While you’re certainly not required to use them, you may find them useful nonetheless.</p><p>The <code class="language-plaintext highlighter-rouge">ASSERT</code> macro is very similar to the assert macro in the C standard library. It’s used as a function that accepts a single boolean value, e.g.:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ASSERT(x &lt; 7)
</code></pre></div></div><p>If that expression evaluates to a logical <code class="language-plaintext highlighter-rouge">false</code>, a message documenting the exact failure is printed to <code class="language-plaintext highlighter-rouge">stderr</code>, but execution otherwise continues. This is to say, <code class="language-plaintext highlighter-rouge">ASSERT</code> is never fatal.</p><p>The <code class="language-plaintext highlighter-rouge">UNREACHABLE</code> macro is used to mark points in code that should not be possible to reach during execution (typically default labels in exhaustive switch statements), and is also used like a function (e.g. <code class="language-plaintext highlighter-rouge">UNREACHABLE()</code>), despite taking no arguments. When an <code class="language-plaintext highlighter-rouge">UNREACHABLE()</code> statement is executed, it has very similar behavior to an assertion failure; it’s also non-fatal.</p><p>Both <code class="language-plaintext highlighter-rouge">UNREACHABLE</code> and <code class="language-plaintext highlighter-rouge">ASSERT</code> are disabled when compiling in <code class="language-plaintext highlighter-rouge">RELEASE</code> mode, but otherwise stay active in <code class="language-plaintext highlighter-rouge">DEBUG</code> and <code class="language-plaintext highlighter-rouge">OPT</code> mode.</p><hr><footer><p class="text-small text-grey-dk-100 mb-0">Kyle C. Hale © 2024 <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a></p></footer></div></div><div class="search-overlay"></div></div><script type="text/javascript" src="./Project 1 _ CS 562_files/toggle_mode.js"></script>
<div id="teal-job-tracker-root-stable" style="z-index: 2147483647;"><iframe id="teal-job-tracker-iframe-stable" style="background: rgb(255, 255, 255) !important; width: 380px !important; height: 100vh !important; position: fixed !important; inset: 0px -380px auto auto !important; z-index: 2147483647 !important; border: 0px !important; box-shadow: rgba(0, 0, 0, 0.25) 0px 0px 16px -3px !important; transition: right 0.25s ease-in-out !important; transform: none !important;" src="./Project 1 _ CS 562_files/saved_resource.html"></iframe></div><div id="teal-job-tracker-companion-root-stable" style="display: block; z-index: 2147483646; bottom: 58px; right: 0px; position: fixed; height: 60px; width: auto;"></div></body><grammarly-desktop-integration data-grammarly-shadow-root="true"><template shadowrootmode="open"><style>
      div.grammarly-desktop-integration {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border: 0;
        -moz-user-select: none;
        -webkit-user-select: none;
        -ms-user-select:none;
        user-select:none;
      }

      div.grammarly-desktop-integration:before {
        content: attr(data-content);
      }
    </style><div aria-label="grammarly-integration" role="group" tabindex="-1" class="grammarly-desktop-integration" data-content="{&quot;mode&quot;:&quot;full&quot;,&quot;isActive&quot;:true,&quot;isUserDisabled&quot;:false}"></div></template></grammarly-desktop-integration></html>